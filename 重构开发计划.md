# 具身智能机器人后端 V2 重构开发计划

> 基于《重构.md》和《重构补充.md》的架构设计，将现有单进程系统拆分为三个独立项目。
> 本文档详细定义每个项目的技术选型、目录结构、功能模块、接口规范与开发里程碑。

---

## 目录

1. [总体架构概览](#1-总体架构概览)
2. [项目一：FastAPI 管理平面](#2-项目一fastapi-管理平面-control-plane)
3. [项目二：WebSocket 数据平面](#3-项目二websocket-数据平面-data-plane)
4. [项目三：GStreamer/WebRTC 媒体平面](#4-项目三gstreamerwebrtc-媒体平面-media-plane)
5. [跨进程通信设计](#5-跨进程通信设计)
6. [部署与运维](#6-部署与运维)
7. [开发里程碑](#7-开发里程碑)

---

## 1. 总体架构概览

### 1.1 三进程模型

```
┌─────────────────────────────────────────────────────────────────────┐
│                         Client Layer                                 │
│            Web UI / VR客户端 / 运维工具 / 云端服务                      │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
        ▼                       ▼                       ▼
┌───────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   FastAPI     │     │  WebSocket      │     │   GStreamer     │
│ (Python)      │     │  Server (C++)   │     │ + WebRTC (C++)  │
│               │     │                 │     │                 │
│ Port: 8000    │     │ Port: 8765      │     │ Port: 8888      │
│               │     │                 │     │                 │
│ • 认证鉴权     │     │ • 控制意图流     │     │ • RGB视频流      │
│ • 模式切换     │     │ • 状态反馈流     │     │ • 多视角相机     │
│ • 任务管理     │     │ • VR遥操数据     │     │ • 低延迟画面     │
│ • 配置管理     │     │ • 关节状态       │     │                 │
│ • 日志审计     │     │                 │     │                 │
└───────┬───────┘     └────────┬────────┘     └────────┬────────┘
        │                      │                       │
        │                      │                       │
        └──────────────────────┼───────────────────────┘
                               │
                               ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      ROS2 Runtime Layer                              │
│  • 控制闭环 (200Hz+)     • Safety Watchdog    • Hardware Drivers    │
│  • Motion Planning       • 传感器融合          • rosbag 录制         │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 技术选型总览

| 项目 | 语言 | 框架/库 | 理由 |
|------|------|---------|------|
| FastAPI 管理平面 | Python 3.10+ | FastAPI + Pydantic V2 | 开发效率高，适合低频管理接口 |
| WebSocket 数据平面 | C++ 17 | Boost.Beast + Protobuf | 高性能、低延迟、二进制协议 |
| 媒体平面 | C++ | GStreamer + libwebrtc | 硬件加速、低延迟视频传输 |

### 1.3 目录结构规划

```
qyh_jushen_backend/
├── control_plane/          # 项目一：FastAPI 管理平面
├── data_plane/             # 项目二：WebSocket 数据平面
├── media_plane/            # 项目三：GStreamer + WebRTC
├── shared/                 # 共享定义（Proto/消息格式）
├── deploy/                 # 部署配置
│   ├── systemd/           # systemd 服务文件
│   └── docker/            # Docker 配置（可选）
├── docs/                   # 文档
└── scripts/                # 工具脚本
```

---

## 2. 项目一：FastAPI 管理平面 (Control Plane)

### 2.1 项目定位

**职责**：负责系统的管理控制，包括"谁在控制、控制什么、什么时候开始/结束"

**特征**：
- 频率：< 5 Hz
- 协议：HTTP REST + JSON
- 强一致性、可追溯、可审计

**禁止事项**（来自重构.md）：
- ❌ 使用 `asyncio.sleep()` 实现高频循环
- ❌ 订阅 ROS Topic 并持续推流
- ❌ 承载 WebSocket 高频状态流
- ❌ 承载视频/图像流

### 2.2 目录结构

```
control_plane/
├── pyproject.toml          # 项目配置（使用 Poetry 或 pip）
├── requirements.txt
├── alembic.ini             # 数据库迁移配置
├── alembic/                # 迁移脚本
│
├── app/
│   ├── __init__.py
│   ├── main.py             # FastAPI 应用入口
│   ├── config.py           # 配置管理（Pydantic Settings）
│   ├── database.py         # 数据库连接
│   ├── dependencies.py     # FastAPI 依赖注入
│   │
│   ├── api/                # API 路由层
│   │   ├── __init__.py
│   │   ├── v1/
│   │   │   ├── __init__.py
│   │   │   ├── router.py           # v1 路由聚合
│   │   │   ├── auth.py             # 认证接口
│   │   │   ├── system.py           # 系统配置（服务发现）
│   │   │   ├── robot.py            # 机器人信息
│   │   │   ├── control.py          # 控制权管理
│   │   │   ├── mode.py             # 工作模式切换
│   │   │   ├── tasks.py            # 任务生命周期
│   │   │   ├── presets.py          # 预设管理
│   │   │   ├── calibration.py      # 标定管理
│   │   │   ├── recording.py        # 录制管理
│   │   │   └── audit.py            # 审计日志
│   │   └── health.py               # 健康检查
│   │
│   ├── core/               # 核心业务逻辑
│   │   ├── __init__.py
│   │   ├── security.py             # JWT 签发与校验
│   │   ├── control_lock.py         # 控制权互斥锁
│   │   ├── mode_manager.py         # 模式状态机
│   │   └── token_manager.py        # Token 管理
│   │
│   ├── models/             # SQLAlchemy 数据模型
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── task.py
│   │   ├── preset.py
│   │   ├── audit_log.py
│   │   └── session.py              # 会话/控制权记录
│   │
│   ├── schemas/            # Pydantic 请求/响应模型
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── system.py
│   │   ├── robot.py
│   │   ├── task.py
│   │   └── response.py             # 统一响应模型
│   │
│   ├── services/           # 服务层（与其他进程通信）
│   │   ├── __init__.py
│   │   ├── ros2_client.py          # ROS2 服务调用客户端
│   │   ├── ws_coordinator.py       # WebSocket服务协调
│   │   └── media_coordinator.py    # 媒体服务协调
│   │
│   └── utils/              # 工具函数
│       ├── __init__.py
│       └── logger.py
│
└── tests/
    ├── __init__.py
    ├── conftest.py
    └── api/
```

### 2.3 核心功能模块

#### 2.3.1 认证鉴权模块 (`api/v1/auth.py`)

```python
# 接口清单
POST /api/v1/auth/login          # 用户登录，签发 JWT
POST /api/v1/auth/logout         # 用户登出
POST /api/v1/auth/refresh        # Token 刷新
GET  /api/v1/auth/me             # 获取当前用户信息
```

**JWT Payload 设计**：
```json
{
  "sub": "user_id",
  "username": "admin",
  "role": "admin|operator|viewer",
  "permissions": ["teleop", "task_manage", "config"],
  "iat": 1234567890,
  "exp": 1234567890
}
```

#### 2.3.2 系统配置与服务发现 (`api/v1/system.py`)

```python
# 接口清单（重构补充.md 必须实现）
GET /api/v1/system/config        # 获取系统配置（服务发现）
GET /api/v1/system/health        # 系统健康状态
GET /api/v1/system/info          # 系统信息
```

**GET /api/v1/system/config 响应示例**：
```json
{
  "success": true,
  "data": {
    "robot_id": "${sn}",
    "robot_name": "Jushen-001",
    "endpoints": {
      "websocket": "ws://192.168.1.100:8765",
      "webrtc_signaling": "http://192.168.1.100:8888"
    },
    "webrtc": {
      "ice_servers": [
        {"urls": "stun:stun.l.yuanchang.com:19302"}
      ]
    },
    "features": {
      "vr_teleop": true,
      "multi_camera": true,
      "recording": true
    }
  }
}
```

#### 2.3.3 控制权管理 (`api/v1/control.py`)

```python
# 接口清单
POST /api/v1/control/acquire     # 获取控制权
POST /api/v1/control/release     # 释放控制权
POST /api/v1/control/renew       # 续约控制权
GET  /api/v1/control/status      # 查询控制权状态
POST /api/v1/control/force-release  # 强制释放（Admin）
```

**控制权状态机**：
```
┌─────────┐     acquire      ┌─────────┐
│  FREE   │ ───────────────> │  HELD   │
└─────────┘                  └─────────┘
     ▲                            │
     │    release/timeout/        │
     │    force_release           │
     └────────────────────────────┘
```

#### 2.3.4 工作模式管理 (`api/v1/mode.py`)

```python
# 接口清单
GET  /api/v1/mode/current        # 获取当前模式
POST /api/v1/mode/switch         # 切换模式
GET  /api/v1/mode/available      # 获取可用模式列表
```

**模式定义**：
| 模式 | 说明 | 允许操作 |
|------|------|----------|
| `idle` | 空闲 | 状态查询 |
| `teleop` | 遥操作 | VR/手柄控制 |
| `auto` | 自主任务 | 任务执行 |
| `maintenance` | 维护 | 参数配置、标定 |

#### 2.3.5 任务生命周期管理 (`api/v1/tasks.py`)

```python
# 接口清单
POST /api/v1/tasks               # 创建任务
GET  /api/v1/tasks               # 列出任务
GET  /api/v1/tasks/{id}          # 获取任务详情
POST /api/v1/tasks/{id}/start    # 启动任务
POST /api/v1/tasks/{id}/pause    # 暂停任务
POST /api/v1/tasks/{id}/resume   # 恢复任务
POST /api/v1/tasks/{id}/cancel   # 取消任务
DELETE /api/v1/tasks/{id}        # 删除任务
```

#### 2.3.6 预设管理 (`api/v1/presets.py`)

```python
# 接口清单
POST /api/v1/presets             # 创建预设
GET  /api/v1/presets             # 列出预设
GET  /api/v1/presets/{id}        # 获取预设详情
PUT  /api/v1/presets/{id}        # 更新预设
DELETE /api/v1/presets/{id}      # 删除预设
POST /api/v1/presets/{id}/apply  # 应用预设
```

#### 2.3.7 录制管理 (`api/v1/recording.py`)

```python
# 接口清单（仅管理生命周期，实际录制在ROS2层）
POST /api/v1/recording/start     # 开始录制
POST /api/v1/recording/stop      # 停止录制
GET  /api/v1/recording/status    # 获取录制状态
GET  /api/v1/recording/list      # 列出录制文件
```

### 2.4 与其他进程的交互

#### 2.4.1 与 ROS2 Runtime 交互

**方式**：通过 ROS2 Service 调用（rclpy 客户端）

```python
# services/ros2_client.py
class ROS2ServiceClient:
    """ROS2 服务调用客户端（仅用于管理操作）"""
    
    async def switch_mode(self, mode: str) -> bool:
        """切换工作模式"""
        pass
    
    async def start_task(self, task_id: int) -> bool:
        """启动任务"""
        pass
    
    async def emergency_stop(self) -> bool:
        """紧急停止"""
        pass
    
    async def start_recording(self, config: dict) -> str:
        """开始录制，返回 bag 路径"""
        pass
```

**注意**：FastAPI 不订阅高频 Topic，只调用低频 Service。

#### 2.4.2 与 WebSocket Server 交互

**方式**：通过内部 HTTP API 或共享状态（Redis/共享内存）

```python
# services/ws_coordinator.py
class WebSocketCoordinator:
    """WebSocket 服务协调器"""
    
    async def broadcast_mode_change(self, mode: str):
        """广播模式变更"""
        pass
    
    async def notify_control_change(self, holder: dict):
        """通知控制权变更"""
        pass
    
    async def get_active_sessions(self) -> list:
        """获取活跃会话列表"""
        pass
```

### 2.5 数据库设计

**使用 SQLite（本地嵌入式）**，路径：`~/qyh-robot-system/persistent/web/web.db`

```sql
-- 用户表
CREATE TABLE users (
    id INTEGER PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100),
    hashed_password VARCHAR(255) NOT NULL,
    role VARCHAR(20) DEFAULT 'viewer',  -- admin, operator, viewer
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP
);

-- 任务表
CREATE TABLE tasks (
    id INTEGER PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    program JSON,
    status VARCHAR(20) DEFAULT 'pending',
    creator_id INTEGER REFERENCES users(id),
    current_step INTEGER DEFAULT 0,
    total_steps INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP
);

-- 审计日志表
CREATE TABLE audit_logs (
    id INTEGER PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    action VARCHAR(50) NOT NULL,
    resource VARCHAR(50),
    resource_id VARCHAR(50),
    details JSON,
    ip_address VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 控制权会话表
CREATE TABLE control_sessions (
    id INTEGER PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    session_type VARCHAR(20),  -- teleop, auto
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ended_at TIMESTAMP,
    end_reason VARCHAR(50)  -- released, timeout, forced, error
);
```

### 2.6 配置管理

```python
# app/config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # 应用信息
    APP_NAME: str = "QYH Jushen Control Plane"
    APP_VERSION: str = "2.0.0"
    DEBUG: bool = False
    
    # 服务端口
    HOST: str = "0.0.0.0"
    PORT: int = 8000
    
    # 数据库
    DATABASE_URL: str = "sqlite:///~/qyh-robot-system/persistent/web/web.db"
    
    # JWT
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    TOKEN_REFRESH_THRESHOLD_MINUTES: int = 10
    
    # 其他服务地址
    WEBSOCKET_SERVER_URL: str = "ws://127.0.0.1:8765"
    WEBRTC_SIGNALING_URL: str = "http://127.0.0.1:8888"
    
    # ROS2
    ROS_DOMAIN_ID: int = 0
    
    # CORS
    CORS_ORIGINS: str = "*"
    
    class Config:
        env_file = ".env"
```

---

## 3. 项目二：WebSocket 数据平面 (Data Plane)

### 3.1 项目定位

**职责**：负责连续变化的控制意图与状态流传输

**特征**：
- 频率：30-200 Hz
- 协议：WebSocket + 二进制（Protobuf）
- 低延迟、高吞吐

**使用场景**：
- VR/遥操控制意图传输
- 关节状态、TF、IMU 等高频状态推送
- Planning/Execution 状态反馈

**禁止事项**（来自重构.md）：
- ❌ 发送大体积 JSON
- ❌ 无时间戳的数据包
- ❌ 无 Watchdog 保护的控制指令

### 3.2 技术选型

| 组件 | 选择 | 理由 |
|------|------|------|
| 语言 | C++ 17 | 高性能、低延迟 |
| WebSocket | Boost.Beast | 高性能、成熟稳定 |
| 序列化 | Protobuf 3 | 高效二进制、跨语言 |
| 异步 | Boost.Asio | 高效异步 I/O |
| ROS2 | rclcpp | C++ ROS2 客户端 |

### 3.3 目录结构

```
data_plane/
├── CMakeLists.txt
├── package.xml              # ROS2 包配置
├── conanfile.txt            # Conan 依赖管理
│
├── proto/                   # Protobuf 定义
│   ├── common.proto
│   ├── control.proto
│   ├── state.proto
│   └── vr.proto
│
├── include/
│   └── data_plane/
│       ├── server.hpp              # WebSocket 服务器
│       ├── session.hpp             # 会话管理
│       ├── auth.hpp                # JWT 验证
│       ├── message_handler.hpp     # 消息处理器
│       ├── ros2_bridge.hpp         # ROS2 桥接
│       ├── watchdog.hpp            # Watchdog 客户端
│       └── state_cache.hpp         # 状态缓存
│
├── src/
│   ├── main.cpp
│   ├── server.cpp
│   ├── session.cpp
│   ├── auth.cpp
│   ├── message_handler.cpp
│   ├── ros2_bridge.cpp
│   ├── watchdog.cpp
│   └── state_cache.cpp
│
├── config/
│   └── config.yaml          # 配置文件
│
└── test/
    └── ...
```

### 3.4 Protobuf 消息定义

#### 3.4.1 通用定义 (`proto/common.proto`)

```protobuf
syntax = "proto3";
package qyh.dataplane;

// 时间戳（必须携带）
message Timestamp {
    int64 seconds = 1;
    int32 nanos = 2;
}

// 3D 向量
message Vector3 {
    double x = 1;
    double y = 2;
    double z = 3;
}

// 四元数
message Quaternion {
    double x = 1;
    double y = 2;
    double z = 3;
    double w = 4;
}

// 位姿
message Pose {
    Vector3 position = 1;
    Quaternion orientation = 2;
}

// 消息头
message Header {
    Timestamp stamp = 1;
    string frame_id = 2;
    uint64 sequence = 3;
}
```

#### 3.4.2 控制消息 (`proto/control.proto`)

```protobuf
syntax = "proto3";
package qyh.dataplane;
import "common.proto";

// 控制意图类型
enum ControlType {
    CONTROL_NONE = 0;
    CONTROL_VR_TELEOP = 1;      // VR 遥操作
    CONTROL_GAMEPAD = 2;        // 手柄控制
    CONTROL_KEYBOARD = 3;       // 键盘控制
}

// VR 手柄数据
message VRController {
    bool active = 1;
    Pose pose = 2;
    float trigger = 3;          // 0.0 - 1.0
    float grip = 4;             // 0.0 - 1.0
    repeated float joystick = 5; // [x, y]
    repeated bool buttons = 6;   // 按钮状态
    bool clutch_engaged = 7;     // Clutch 状态
}

// VR 控制意图
message VRControlIntent {
    Header header = 1;
    Pose head_pose = 2;
    VRController left_hand = 3;
    VRController right_hand = 4;
}

// 底盘速度命令
message ChassisVelocity {
    Header header = 1;
    double linear_x = 2;
    double linear_y = 3;
    double angular_z = 4;
}

// 关节位置命令
message JointCommand {
    Header header = 1;
    repeated string names = 2;
    repeated double positions = 3;
    repeated double velocities = 4;
}

// 心跳消息
message Heartbeat {
    Header header = 1;
    string session_id = 2;
}
```

#### 3.4.3 状态消息 (`proto/state.proto`)

```protobuf
syntax = "proto3";
package qyh.dataplane;
import "common.proto";

// 关节状态
message JointState {
    Header header = 1;
    repeated string names = 2;
    repeated double positions = 3;
    repeated double velocities = 4;
    repeated double efforts = 5;
}

// 机械臂状态
message ArmState {
    Header header = 1;
    bool connected = 2;
    bool powered_on = 3;
    bool enabled = 4;
    bool in_estop = 5;
    bool in_error = 6;
    bool servo_mode = 7;
    string error_message = 8;
    repeated double left_positions = 9;
    repeated double right_positions = 10;
}

// 底盘状态
message ChassisState {
    Header header = 1;
    Pose odom = 2;
    Vector3 velocity = 3;
    double battery_level = 4;
    bool charging = 5;
    int32 navigation_status = 6;
}

// IMU 数据
message ImuData {
    Header header = 1;
    Quaternion orientation = 2;
    Vector3 angular_velocity = 3;
    Vector3 linear_acceleration = 4;
}

// 机器人综合状态
message RobotState {
    Header header = 1;
    ArmState arm = 2;
    ChassisState chassis = 3;
    JointState joints = 4;
}
```

### 3.5 核心功能模块

#### 3.5.1 WebSocket 服务器

```cpp
// include/data_plane/server.hpp
class WebSocketServer {
public:
    explicit WebSocketServer(const Config& config);
    
    void start();
    void stop();
    
    // 广播消息到所有会话
    void broadcast(const std::vector<uint8_t>& data);
    
    // 广播到特定订阅者
    void broadcast_to_subscribers(
        const std::string& topic,
        const std::vector<uint8_t>& data
    );
    
private:
    boost::asio::io_context io_context_;
    boost::asio::ip::tcp::acceptor acceptor_;
    std::unordered_map<std::string, std::shared_ptr<Session>> sessions_;
};
```

#### 3.5.2 会话管理

```cpp
// include/data_plane/session.hpp
class Session : public std::enable_shared_from_this<Session> {
public:
    // 会话状态
    enum class State {
        CONNECTING,     // 连接中（等待鉴权）
        AUTHENTICATED,  // 已认证
        ACTIVE,         // 活跃（已订阅）
        CLOSING         // 关闭中
    };
    
    // 用户信息（从 JWT 解析）
    struct UserInfo {
        int64_t user_id;
        std::string username;
        std::string role;
        std::vector<std::string> permissions;
    };
    
    // 订阅的话题
    std::set<std::string> subscriptions;
    
    // 是否有控制权
    bool has_control_permission() const;
    
    // 发送消息
    void send(const std::vector<uint8_t>& data);
    
private:
    State state_;
    UserInfo user_info_;
    std::chrono::steady_clock::time_point last_heartbeat_;
};
```

#### 3.5.3 JWT 验证

```cpp
// include/data_plane/auth.hpp
class JWTValidator {
public:
    explicit JWTValidator(const std::string& secret);
    
    // 验证 Token（在 WebSocket Upgrade 时调用）
    std::optional<Session::UserInfo> validate(const std::string& token);
    
private:
    std::string secret_;
};
```

#### 3.5.4 消息处理器

```cpp
// include/data_plane/message_handler.hpp
class MessageHandler {
public:
    // 处理入站消息
    void handle_message(
        std::shared_ptr<Session> session,
        const std::vector<uint8_t>& data
    );
    
private:
    // 处理 VR 控制意图
    void handle_vr_control(
        std::shared_ptr<Session> session,
        const VRControlIntent& intent
    );
    
    // 处理心跳
    void handle_heartbeat(
        std::shared_ptr<Session> session,
        const Heartbeat& hb
    );
    
    // 处理订阅请求
    void handle_subscribe(
        std::shared_ptr<Session> session,
        const SubscribeRequest& req
    );
    
    ROS2Bridge& ros2_bridge_;
    Watchdog& watchdog_;
};
```

#### 3.5.5 ROS2 桥接

```cpp
// include/data_plane/ros2_bridge.hpp
class ROS2Bridge {
public:
    void initialize();
    void spin();
    
    // 订阅状态（从 ROS2 到 WebSocket）
    using StateCallback = std::function<void(const RobotState&)>;
    void set_state_callback(StateCallback cb);
    
    // 发布控制意图（从 WebSocket 到 ROS2）
    void publish_vr_intent(const VRControlIntent& intent);
    void publish_chassis_velocity(const ChassisVelocity& vel);
    void publish_joint_command(const JointCommand& cmd);
    
private:
    rclcpp::Node::SharedPtr node_;
    
    // 订阅器
    rclcpp::Subscription<JointState>::SharedPtr joint_state_sub_;
    rclcpp::Subscription<ArmState>::SharedPtr arm_state_sub_;
    
    // 发布器
    rclcpp::Publisher<VRTeleopMsg>::SharedPtr vr_intent_pub_;
    rclcpp::Publisher<Twist>::SharedPtr cmd_vel_pub_;
};
```

#### 3.5.6 Watchdog 集成

```cpp
// include/data_plane/watchdog.hpp
class Watchdog {
public:
    // 初始化（连接到 ROS2 Watchdog 节点）
    void initialize(rclcpp::Node::SharedPtr node);
    
    // 喂狗（收到有效控制意图时调用）
    void feed(const std::string& session_id);
    
    // 检查会话是否超时
    bool is_session_timeout(const std::string& session_id);
    
private:
    // 超时阈值（200ms）
    static constexpr auto TIMEOUT = std::chrono::milliseconds(200);
    
    std::unordered_map<std::string, std::chrono::steady_clock::time_point> 
        session_heartbeats_;
    
    rclcpp::Publisher<WatchdogHeartbeat>::SharedPtr heartbeat_pub_;
};
```

### 3.6 消息协议设计

#### 3.6.1 消息帧格式

```
+--------+--------+----------------+----------------+
| Magic  | Type   | Length (4B)    | Payload        |
| (2B)   | (2B)   | (Big Endian)   | (Protobuf)     |
+--------+--------+----------------+----------------+
| 0x51   | 0x59   | Message Type   | Protobuf bytes |
| 'Q'    | 'Y'    |                |                |
+--------+--------+----------------+----------------+
```

#### 3.6.2 消息类型定义

| Type ID | 名称 | 方向 | 说明 |
|---------|------|------|------|
| 0x0001 | AUTH_REQUEST | Client→Server | 认证请求（含JWT） |
| 0x0002 | AUTH_RESPONSE | Server→Client | 认证响应 |
| 0x0010 | SUBSCRIBE | Client→Server | 订阅请求 |
| 0x0011 | UNSUBSCRIBE | Client→Server | 取消订阅 |
| 0x0020 | HEARTBEAT | 双向 | 心跳 |
| 0x0100 | VR_CONTROL | Client→Server | VR 控制意图 |
| 0x0101 | CHASSIS_VEL | Client→Server | 底盘速度 |
| 0x0102 | JOINT_CMD | Client→Server | 关节命令 |
| 0x0200 | ROBOT_STATE | Server→Client | 机器人状态 |
| 0x0201 | JOINT_STATE | Server→Client | 关节状态 |
| 0x0202 | ARM_STATE | Server→Client | 机械臂状态 |
| 0x0300 | ERROR | Server→Client | 错误消息 |

### 3.7 配置文件

```yaml
# config/config.yaml
server:
  host: "0.0.0.0"
  port: 8765
  max_connections: 50

auth:
  jwt_secret: "${JWT_SECRET}"
  jwt_algorithm: "HS256"
  # 连接建立后的鉴权超时（秒）
  auth_timeout: 10

ros2:
  domain_id: 0
  node_name: "ws_data_plane"

watchdog:
  timeout_ms: 200
  
state_publish:
  # 状态推送频率
  robot_state_hz: 30
  joint_state_hz: 100
  
logging:
  level: "INFO"
  file: "/var/log/qyh/data_plane.log"
```

---

## 4. 项目三：GStreamer/WebRTC 媒体平面 (Media Plane)

### 4.1 项目定位

**职责**：负责人类感知所需的多媒体数据传输

**特征**：
- 超高吞吐量
- 硬件加速编码（NVENC）
- 低延迟（< 100ms）

**使用场景**：
- RGB 视频流
- 多视角摄像头（头部、左手、右手）
- VR 遥操低延迟画面

**设计约束**（来自重构.md）：
- ✅ 必须使用硬件编码（Jetson NVENC）
- ❌ 禁止通过 WebSocket/HTTP 传输视频
- ✅ 所有帧需附带系统时间戳

### 4.2 技术选型

| 组件 | 选择 | 理由 |
|------|------|------|
| 语言 | C++ / GStreamer (C) | 高性能 |
| 媒体框架 | GStreamer 1.20+ | Jetson 原生支持、硬件加速 |
| WebRTC | gstreamer-webrtc | 与 GStreamer 集成 |
| Signaling | 简单 HTTP + WebSocket | 轻量级信令 |

### 4.3 目录结构

```
media_plane/
├── CMakeLists.txt
├── package.xml
│
├── include/
│   └── media_plane/
│       ├── pipeline_manager.hpp    # Pipeline 管理
│       ├── camera_source.hpp       # 相机源
│       ├── encoder.hpp             # 编码器封装
│       ├── webrtc_peer.hpp         # WebRTC Peer
│       ├── signaling_server.hpp    # 信令服务器
│       └── auth.hpp                # 鉴权
│
├── src/
│   ├── main.cpp
│   ├── pipeline_manager.cpp
│   ├── camera_source.cpp
│   ├── encoder.cpp
│   ├── webrtc_peer.cpp
│   └── signaling_server.cpp
│
├── config/
│   └── config.yaml
│
└── web/                        # 简单的测试页面
    └── index.html
```

### 4.4 核心功能模块

#### 4.4.1 Pipeline 管理器

```cpp
// include/media_plane/pipeline_manager.hpp
class PipelineManager {
public:
    // 创建相机 Pipeline
    // v4l2src -> nvvidconv -> nvv4l2h264enc -> rtph264pay -> webrtcbin
    bool create_camera_pipeline(
        const std::string& camera_id,
        const CameraConfig& config
    );
    
    // 获取 webrtcbin 用于 WebRTC 连接
    GstElement* get_webrtc_bin(const std::string& camera_id);
    
    // 启动/停止 Pipeline
    void start_pipeline(const std::string& camera_id);
    void stop_pipeline(const std::string& camera_id);
    
private:
    std::unordered_map<std::string, GstElement*> pipelines_;
};
```

#### 4.4.2 GStreamer Pipeline 设计

**单相机 Pipeline**：

```
v4l2src device=/dev/video0
    ↓
nvvidconv (色彩空间转换)
    ↓
nvv4l2h264enc (Jetson NVENC 硬件编码)
    • bitrate=4000000 (4 Mbps)
    • preset-level=3 (低延迟)
    • maxperf-enable=true
    ↓
rtph264pay (RTP 打包)
    ↓
webrtcbin (WebRTC 传输)
```

**Pipeline 字符串示例**：

```cpp
const char* pipeline_desc = 
    "v4l2src device=/dev/video0 ! "
    "video/x-raw,width=1280,height=720,framerate=30/1 ! "
    "nvvidconv ! "
    "video/x-raw(memory:NVMM),format=NV12 ! "
    "nvv4l2h264enc bitrate=4000000 preset-level=3 maxperf-enable=true ! "
    "video/x-h264,stream-format=byte-stream ! "
    "rtph264pay config-interval=1 pt=96 ! "
    "application/x-rtp,media=video,encoding-name=H264 ! "
    "webrtcbin name=webrtc";
```

#### 4.4.3 信令服务器

```cpp
// include/media_plane/signaling_server.hpp
class SignalingServer {
public:
    explicit SignalingServer(uint16_t port);
    
    void start();
    void stop();
    
    // HTTP 端点
    // POST /api/v1/webrtc/offer   - 接收 SDP Offer
    // POST /api/v1/webrtc/ice     - 接收 ICE Candidate
    
private:
    // 处理 WebRTC Offer
    std::string handle_offer(
        const std::string& camera_id,
        const std::string& sdp_offer,
        const std::string& jwt_token
    );
    
    // JWT 验证
    bool verify_token(const std::string& token);
};
```

#### 4.4.4 WebRTC Peer 连接

```cpp
// include/media_plane/webrtc_peer.hpp
class WebRTCPeer {
public:
    WebRTCPeer(GstElement* webrtcbin, const std::string& peer_id);
    
    // 处理 SDP
    void set_remote_description(const std::string& sdp);
    std::string create_answer();
    
    // 处理 ICE
    void add_ice_candidate(const std::string& candidate, int sdp_mline_index);
    
    // 连接状态回调
    using StateCallback = std::function<void(const std::string& state)>;
    void set_state_callback(StateCallback cb);
    
private:
    GstElement* webrtcbin_;
    std::string peer_id_;
};
```

### 4.5 信令协议设计

#### 4.5.1 建立连接流程

```
Client                    Signaling Server              GStreamer Pipeline
   │                            │                              │
   │ ──── POST /offer ────────> │                              │
   │      (JWT + SDP Offer)     │                              │
   │                            │ ── create_answer() ────────> │
   │                            │ <── SDP Answer ───────────── │
   │ <─── 200 (SDP Answer) ──── │                              │
   │                            │                              │
   │ ──── POST /ice ──────────> │                              │
   │      (ICE Candidate)       │ ── add_ice_candidate() ───> │
   │ <─── 200 ────────────────  │                              │
   │                            │                              │
   │ <═══════════════ WebRTC Media Stream ═══════════════════> │
```

#### 4.5.2 API 定义

```yaml
# POST /api/v1/webrtc/offer
Request:
  headers:
    Authorization: "Bearer <JWT>"
  body:
    camera_id: "head"          # head, left_hand, right_hand
    sdp: "<SDP Offer string>"
    
Response:
  success: true
  data:
    sdp: "<SDP Answer string>"
    session_id: "uuid"

# POST /api/v1/webrtc/ice
Request:
  headers:
    Authorization: "Bearer <JWT>"
  body:
    session_id: "uuid"
    candidate: "<ICE Candidate>"
    sdp_mline_index: 0

Response:
  success: true
```

### 4.6 配置文件

```yaml
# config/config.yaml
server:
  signaling_port: 8888

cameras:
  head:
    device: "/dev/video0"
    width: 1280
    height: 720
    fps: 30
    bitrate: 4000000  # 4 Mbps
  
  left_hand:
    device: "/dev/video2"
    width: 640
    height: 480
    fps: 30
    bitrate: 2000000  # 2 Mbps
    
  right_hand:
    device: "/dev/video4"
    width: 640
    height: 480
    fps: 30
    bitrate: 2000000

webrtc:
  stun_server: "stun:stun.l.google.com:19302"
  # 可选 TURN 服务器
  turn_servers: []

auth:
  jwt_secret: "${JWT_SECRET}"

logging:
  level: "INFO"
  file: "/var/log/qyh/media_plane.log"
```

---

## 5. 跨进程通信设计

### 5.1 进程间通信方式

| 通信路径 | 方式 | 说明 |
|----------|------|------|
| FastAPI ↔ WebSocket Server | HTTP (内部) | 会话通知、状态同步 |
| FastAPI ↔ Media Plane | HTTP (内部) | 健康检查 |
| FastAPI ↔ ROS2 | ROS2 Service | 管理操作 |
| WebSocket ↔ ROS2 | ROS2 Pub/Sub | 高频数据 |
| Media ↔ ROS2 | 共享内存(可选) | 相机数据（若需要） |

### 5.2 共享配置

所有进程共享同一个 JWT Secret，用于跨进程鉴权。

```bash
# /etc/qyh-robot/shared.env
JWT_SECRET=your-super-secret-key-here
ROS_DOMAIN_ID=0
```

### 5.3 统一时间源

所有进程使用系统时钟（`CLOCK_REALTIME`），确保：
- ROS 消息时间戳
- WebSocket 消息时间戳
- 视频帧时间戳

三者可对齐。

---

## 6. 部署与运维

### 6.1 systemd 服务配置

#### FastAPI (Control Plane)

```ini
# /etc/systemd/system/qyh-control-plane.service
[Unit]
Description=QYH Robot Control Plane (FastAPI)
After=network.target

[Service]
Type=simple
User=robot
WorkingDirectory=/opt/qyh-robot/control_plane
EnvironmentFile=/etc/qyh-robot/shared.env
ExecStart=/opt/qyh-robot/venv/bin/uvicorn app.main:app --host 0.0.0.0 --port 8000
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

#### WebSocket Server (Data Plane)

```ini
# /etc/systemd/system/qyh-data-plane.service
[Unit]
Description=QYH Robot Data Plane (WebSocket)
After=network.target ros2.service

[Service]
Type=simple
User=robot
EnvironmentFile=/etc/qyh-robot/shared.env
ExecStart=/opt/qyh-robot/data_plane/build/data_plane_server
Restart=always
RestartSec=3
# 更高优先级
Nice=-10

[Install]
WantedBy=multi-user.target
```

#### Media Plane

```ini
# /etc/systemd/system/qyh-media-plane.service
[Unit]
Description=QYH Robot Media Plane (WebRTC)
After=network.target

[Service]
Type=simple
User=robot
EnvironmentFile=/etc/qyh-robot/shared.env
ExecStart=/opt/qyh-robot/media_plane/build/media_plane_server
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

### 6.2 日志管理

```bash
# 查看日志
journalctl -u qyh-control-plane -f
journalctl -u qyh-data-plane -f
journalctl -u qyh-media-plane -f

# 查看所有 QYH 服务日志
journalctl -u 'qyh-*' -f
```

### 6.3 Jetson 性能优化

```bash
# 启动脚本中执行
sudo nvpmodel -m 0           # 最大性能模式
sudo jetson_clocks           # 锁定最大频率

# CPU 亲和性设置
# 控制平面（低优先级）：CPU 0-1
# 数据平面（高优先级）：CPU 2-3
# 媒体平面：CPU 4-5
# ROS2：CPU 6-7
```

---

## 7. 开发里程碑

### Phase 1: 基础框架 (2 周)

#### Week 1
- [ ] 创建三个项目的目录结构
- [ ] FastAPI 基础框架搭建
  - [ ] 配置管理
  - [ ] 数据库初始化
  - [ ] 认证模块
  - [ ] 统一响应格式
- [ ] 定义 Protobuf 消息格式

#### Week 2
- [ ] WebSocket Server (C++) 基础框架
  - [ ] Boost.Beast WebSocket 服务器
  - [ ] 会话管理
  - [ ] JWT 验证
- [ ] Media Plane 基础框架
  - [ ] GStreamer Pipeline 原型
  - [ ] 简单信令服务器

### Phase 2: 核心功能 (3 周)

#### Week 3
- [ ] FastAPI 完整 API 实现
  - [ ] 系统配置与服务发现
  - [ ] 控制权管理
  - [ ] 模式切换
  - [ ] 任务管理

#### Week 4
- [ ] WebSocket Server 功能完善
  - [ ] ROS2 桥接
  - [ ] 状态订阅/推送
  - [ ] VR 控制意图处理
  - [ ] Watchdog 集成

#### Week 5
- [ ] Media Plane 功能完善
  - [ ] 多相机支持
  - [ ] WebRTC 完整流程
  - [ ] 硬件编码优化

### Phase 3: 集成与测试 (2 周)

#### Week 6
- [ ] 三进程集成测试
- [ ] 跨进程鉴权验证
- [ ] 端到端延迟测试
- [ ] 压力测试

#### Week 7
- [ ] Bug 修复
- [ ] 性能优化
- [ ] 文档完善
- [ ] systemd 服务配置

### Phase 4: 部署与验收 (1 周)

#### Week 8
- [ ] Jetson 部署
- [ ] 实机测试
- [ ] 性能调优
- [ ] 交付文档

---

## 附录

### A. 旧代码功能映射

| 旧模块 | 新归属 | 说明 |
|--------|--------|------|
| `app/api/auth.py` | Control Plane | 保留 |
| `app/api/control.py` | Control Plane | 保留 |
| `app/api/tasks.py` | Control Plane | 保留 |
| `app/api/websocket.py` | Data Plane | 重写为 C++ |
| `app/api/camera.py` | Media Plane | 重写为 WebRTC |
| `app/api/vr_teleoperation.py` | Data Plane | 状态查询保留在 Control Plane |
| `app/ros2_bridge/` | Data Plane | 重写为 C++ |
| `app/safety/watchdog.py` | Data Plane + ROS2 | Watchdog 逻辑迁移到 ROS2 |

### B. 环境变量清单

```bash
# 共享
JWT_SECRET=<secret>
ROS_DOMAIN_ID=0

# Control Plane
CONTROL_PLANE_PORT=8000
DATABASE_URL=sqlite:///...

# Data Plane
DATA_PLANE_PORT=8765
DATA_PLANE_STATE_HZ=30

# Media Plane
MEDIA_PLANE_SIGNALING_PORT=8888
```

### C. 依赖清单

#### Control Plane (Python)
```
fastapi>=0.109.0
uvicorn[standard]>=0.27.0
pydantic>=2.5.0
pydantic-settings>=2.1.0
sqlalchemy>=2.0.0
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
```

#### Data Plane (C++)
```
boost>=1.81.0
protobuf>=3.21.0
rclcpp (ROS2 Humble)
jwt-cpp
```

#### Media Plane (C++)
```
gstreamer-1.0>=1.20
gst-plugins-base
gst-plugins-good
gst-plugins-bad (webrtc)
libsoup-2.4
json-glib-1.0
```
